name: Convert Issue to Blog Post

on:
  issues:
    types: [labeled]

jobs:
  create-post:
    # Only run when the 'new post' label is added
    if: github.event.label.name == 'new post'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
          
      - name: Parse issue body and create blog post
        id: create-post
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body;
            const issueNumber = context.payload.issue.number;
            const issueTitle = context.payload.issue.title.replace('[BLOG]: ', '');
            
            // Parse the issue body to extract form fields
            const parseField = (fieldName) => {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\n([\\s\\S]*?)(?=\\n\\n###|$)`, 'i');
              const match = issueBody.match(regex);
              return match ? match[1].trim() : '';
            };
            
            // Extract all fields
            const title = parseField('Post Title');
            const category = parseField('Category');
            const excerpt = parseField('Post Excerpt');
            let content = parseField('Post Content');
            const tags = parseField('Tags');
            const author = parseField('Author') || 'Matt Griffin';
            
            // Generate filename
            const date = new Date().toISOString().split('T')[0];
            const slug = title.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-+|-+$/g, '');
            const filename = `${date}-${slug}.md`;
            
            // Find and collect image URLs from HTML img tags
            // Matches: <img src="https://github.com/user-attachments/assets/..." alt="..." />
            const imgTagRegex = /<img[^>]+src="(https:\/\/github\.com\/user-attachments\/assets\/[^"]+)"[^>]*(?:alt="([^"]*)")?[^>]*>/g;
            const imageUrls = [];
            const imageReplacements = new Map();
            
            let match;
            let imageCounter = 1;
            while ((match = imgTagRegex.exec(content)) !== null) {
              const fullMatch = match[0];
              const url = match[1];
              const altText = match[2] || `Image ${imageCounter}`;
              
              // Generate local filename for image
              const imageId = url.split('/').pop().split('?')[0];
              const localImagePath = `/assets/img/${date}-${slug}-${imageId}`;
              
              imageUrls.push({ url, localPath: localImagePath, altText });
              
              // Replace HTML img tag with markdown image syntax
              imageReplacements.set(fullMatch, `![${altText}]({{ site.baseurl }}${localImagePath})`);
              imageCounter++;
            }
            
            // Also check for direct GitHub attachment URLs that might not be in img tags
            const directUrlRegex = /(?<!src=")https:\/\/github\.com\/user-attachments\/assets\/[^\s<>"]+/g;
            let directMatch;
            while ((directMatch = directUrlRegex.exec(content)) !== null) {
              const url = directMatch[0];
              // Skip if this URL was already found in an img tag
              if (!Array.from(imageReplacements.keys()).some(key => key.includes(url))) {
                const imageId = url.split('/').pop().split('?')[0];
                const localImagePath = `/assets/img/${date}-${slug}-${imageId}`;
                
                imageUrls.push({ url, localPath: localImagePath, altText: `Image ${imageCounter}` });
                imageReplacements.set(url, `![Image ${imageCounter}]({{ site.baseurl }}${localImagePath})`);
                imageCounter++;
              }
            }
            
            // Replace image URLs in content
            for (const [original, replacement] of imageReplacements) {
              content = content.replace(new RegExp(original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), replacement);
            }
            
            // Format tags for frontmatter
            const tagList = tags ? tags.split(',').map(t => t.trim()).filter(t => t) : [];
            const tagYaml = tagList.length > 0 
              ? '\ntags:\n' + tagList.map(t => `- ${t}`).join('\n')
              : '';
            
            // Create the blog post content
            const postContent = `---
            title: "${title}"
            date: ${date}
            categories:
            - "${category}"
            excerpt: "${excerpt}"
            author: "${author}"${tagYaml}
            ---
            
            ${content}`;
            
            // Write file using Node.js fs
            const fs = require('fs');
            const path = require('path');
            const filepath = path.join('_posts', filename);
            
            // Ensure _posts directory exists
            if (!fs.existsSync('_posts')) {
              fs.mkdirSync('_posts', { recursive: true });
            }
            
            // Write the file
            fs.writeFileSync(filepath, postContent.replace(/^            /gm, ''));
            
            // Set outputs
            core.setOutput('filename', filename);
            core.setOutput('title', title);
            core.setOutput('filepath', filepath);
            core.setOutput('slug', slug);
            core.setOutput('date', date);
            core.setOutput('images', JSON.stringify(imageUrls));
            
      - name: Download images from issue
        if: steps.create-post.outputs.images != '[]'
        run: |
          # Parse images JSON
          IMAGES='${{ steps.create-post.outputs.images }}'
          DATE='${{ steps.create-post.outputs.date }}'
          SLUG='${{ steps.create-post.outputs.slug }}'
          
          # Ensure assets/img directory exists
          mkdir -p assets/img
          
          # Download each image
          echo "$IMAGES" | jq -c '.[]' | while read -r image; do
            URL=$(echo "$image" | jq -r '.url')
            LOCAL_PATH=$(echo "$image" | jq -r '.localPath')
            
            # Extract just the filename from the local path
            FILENAME=$(basename "$LOCAL_PATH")
            
            echo "Downloading image from $URL to assets/img/$FILENAME"
            
            # Download the image using curl with GitHub token for authentication
            curl -L -H "Authorization: token ${{ github.token }}" \
                 -H "Accept: application/octet-stream" \
                 "$URL" -o "assets/img/$FILENAME"
            
            # Check if download was successful
            if [ -f "assets/img/$FILENAME" ]; then
              echo "Successfully downloaded $FILENAME"
            else
              echo "Failed to download $FILENAME"
            fi
          done
          
      - name: Create branch and commit
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Create and checkout new branch
          BRANCH_NAME="blog-post/issue-${{ github.event.issue.number }}"
          
          # Delete the branch if it exists (from previous failed runs)
          git push origin --delete $BRANCH_NAME 2>/dev/null || true
          
          # Create fresh branch
          git checkout -b $BRANCH_NAME
          
          # Add the new blog post file and any downloaded images
          git add _posts/${{ steps.create-post.outputs.filename }}
          
          # Add images if they exist
          if [ -d "assets/img" ] && [ "$(ls -A assets/img 2>/dev/null)" ]; then
            git add assets/img/*
          fi
          
          # Commit
          git commit -m "Add blog post: ${{ steps.create-post.outputs.title }}
          
          Generated from issue #${{ github.event.issue.number }}"
          
          # Push the branch
          git push origin $BRANCH_NAME
          
      - name: Convert issue to pull request
        uses: actions/github-script@v7
        with:
          script: |
            // Create PR from the branch we just pushed - using issue number to link them
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue: context.issue.number,  // This converts the issue to a PR
              head: `blog-post/issue-${context.issue.number}`,
              base: 'main'
            });
            
            // Add labels to the PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['blog-post']
            });
            
            // Add a comment to note the conversion
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## âœ… Converted to Pull Request\n\nThis issue has been converted to pull request #${pr.number}.\n\nðŸ“„ **Blog post file**: \`_posts/${{ steps.create-post.outputs.filename }}\`\n\nYou can now review and merge the PR when ready to publish.`
            });
            
            // Add 'processed' label to the original issue
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['processed']
            });