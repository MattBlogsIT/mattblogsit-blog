name: Convert Issue to Blog Post

on:
  issues:
    types: [labeled]

jobs:
  create-post:
    # Only run when the 'new post' label is added
    if: github.event.label.name == 'new post'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
          
      - name: Parse issue body and create blog post
        id: create-post
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body;
            const issueNumber = context.payload.issue.number;
            const issueTitle = context.payload.issue.title.replace('[BLOG]: ', '');
            
            // Parse the issue body to extract form fields
            const parseField = (fieldName) => {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\n([\\s\\S]*?)(?=\\n\\n###|$)`, 'i');
              const match = issueBody.match(regex);
              return match ? match[1].trim() : '';
            };
            
            // Extract all fields
            const title = parseField('Post Title');
            const category = parseField('Category');
            const excerpt = parseField('Post Excerpt');
            let content = parseField('Post Content');
            const tags = parseField('Tags');
            const author = parseField('Author') || 'Matt Griffin';
            
            // Generate filename
            const date = new Date().toISOString().split('T')[0];
            const slug = title.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-+|-+$/g, '');
            const filename = `${date}-${slug}.md`;
            
            // Find and collect image URLs from HTML img tags
            // Matches img tags with GitHub user-attachments URLs
            const imgTagRegex = /<img[^>]*>/g;
            const imageUrls = [];
            const imageReplacements = new Map();
            
            let match;
            let imageCounter = 1;
            while ((match = imgTagRegex.exec(content)) !== null) {
              const fullMatch = match[0];
              
              // Extract src URL
              const srcMatch = fullMatch.match(/src="(https:\/\/github\.com\/user-attachments\/assets\/[^"]+)"/);
              if (!srcMatch) continue;
              const url = srcMatch[1];
              
              // Extract alt text - check for alt attribute anywhere in the tag
              const altMatch = fullMatch.match(/alt="([^"]*)"/);
              const altText = altMatch ? altMatch[1] : `Image ${imageCounter}`;
              
              // Generate local filename for image - preserve extension if present
              const urlParts = url.split('/').pop().split('?')[0];
              const imageId = urlParts;
              // Check if the URL has a file extension, if not, try to detect from URL or default to .png
              const hasExtension = /\.[a-z0-9]{2,4}$/i.test(imageId);
              const finalImageName = hasExtension ? imageId : `${imageId}.png`;
              const localImagePath = `/assets/img/${date}-${slug}-${finalImageName}`;
              
              imageUrls.push({ url, localPath: localImagePath, altText });
              
              // Check if there's text immediately after the img tag that could be a caption
              const remainingContent = content.substr(content.indexOf(fullMatch) + fullMatch.length);
              const captionMatch = remainingContent.match(/^\s*([^\n<]+)/);
              const hasCaption = captionMatch && captionMatch[1].trim().length > 0;
              
              if (hasCaption) {
                // Use HTML figure/figcaption for images with captions
                const caption = captionMatch[1].trim();
                const figureHtml = '<figure class="aligncenter">\n' +
                  '  <img src="' + '{{ site.baseurl }}' + localImagePath + '" alt="' + altText + '">\n' +
                  '  <figcaption>' + caption + '</figcaption>\n' +
                  '</figure>';
                imageReplacements.set(fullMatch + captionMatch[0], figureHtml);
              } else {
                // Use markdown for images without captions
                imageReplacements.set(fullMatch, '![' + altText + '](' + '{{ site.baseurl }}' + localImagePath + ')');
              }
              imageCounter++;
            }
            
            // Also check for direct GitHub attachment URLs that might not be in img tags
            const directUrlRegex = /(?<!src=")https:\/\/github\.com\/user-attachments\/assets\/[^\s<>"]+/g;
            let directMatch;
            while ((directMatch = directUrlRegex.exec(content)) !== null) {
              const url = directMatch[0];
              // Skip if this URL was already found in an img tag
              if (!Array.from(imageReplacements.keys()).some(key => key.includes(url))) {
                // Generate local filename for direct URL - preserve extension if present
                const urlParts = url.split('/').pop().split('?')[0];
                const imageId = urlParts;
                const hasExtension = /\.[a-z0-9]{2,4}$/i.test(imageId);
                const finalImageName = hasExtension ? imageId : `${imageId}.png`;
                const localImagePath = `/assets/img/${date}-${slug}-${finalImageName}`;
                
                imageUrls.push({ url, localPath: localImagePath, altText: `Image ${imageCounter}` });
                imageReplacements.set(url, `![Image ${imageCounter}]({{ site.baseurl }}${localImagePath})`);
                imageCounter++;
              }
            }
            
            // Replace image URLs in content
            for (const [original, replacement] of imageReplacements) {
              content = content.replace(new RegExp(original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), replacement);
            }
            
            // Format tags for frontmatter
            const tagList = tags ? tags.split(',').map(t => t.trim()).filter(t => t) : [];
            const tagYaml = tagList.length > 0 
              ? '\ntags:\n' + tagList.map(t => `- ${t}`).join('\n')
              : '';
            
            // Create the blog post content
            const postContent = `---
            title: "${title}"
            date: ${date}
            categories:
            - "${category}"
            excerpt: "${excerpt}"
            author: "${author}"${tagYaml}
            ---
            
            ${content}`;
            
            // Write file using Node.js fs
            const fs = require('fs');
            const path = require('path');
            const filepath = path.join('_posts', filename);
            
            // Ensure _posts directory exists
            if (!fs.existsSync('_posts')) {
              fs.mkdirSync('_posts', { recursive: true });
            }
            
            // Write the file
            fs.writeFileSync(filepath, postContent.replace(/^            /gm, ''));
            
            // Set outputs
            core.setOutput('filename', filename);
            core.setOutput('title', title);
            core.setOutput('filepath', filepath);
            core.setOutput('slug', slug);
            core.setOutput('date', date);
            core.setOutput('images', JSON.stringify(imageUrls));
            
      - name: Download images from issue
        if: steps.create-post.outputs.images != '[]'
        run: |
          # Parse images JSON
          IMAGES='${{ steps.create-post.outputs.images }}'
          DATE='${{ steps.create-post.outputs.date }}'
          SLUG='${{ steps.create-post.outputs.slug }}'

          # Ensure assets/img directory exists
          mkdir -p assets/img

          # Download each image
          echo "$IMAGES" | jq -c '.[]' | while read -r image; do
            URL=$(echo "$image" | jq -r '.url')
            LOCAL_PATH=$(echo "$image" | jq -r '.localPath')

            # Extract just the filename from the local path
            FILENAME=$(basename "$LOCAL_PATH")

            echo "Downloading image from $URL to assets/img/$FILENAME"

            # Download the image using curl with GitHub token for authentication
            curl -L -H "Authorization: token ${{ github.token }}" \
                 -H "Accept: application/octet-stream" \
                 "$URL" -o "assets/img/$FILENAME"

            # Check if download was successful
            if [ -f "assets/img/$FILENAME" ]; then
              echo "Successfully downloaded $FILENAME"
            else
              echo "Failed to download $FILENAME"
            fi
          done

      - name: Optimize downloaded images
        if: steps.create-post.outputs.images != '[]'
        run: |
          # Install image optimization tools
          sudo apt-get update
          sudo apt-get install -y imagemagick optipng jpegoptim webp

          # Parse images JSON to get list of downloaded files
          IMAGES='${{ steps.create-post.outputs.images }}'

          echo "Starting automatic image optimization..."

          # Process each downloaded image
          echo "$IMAGES" | jq -c '.[]' | while read -r image; do
            LOCAL_PATH=$(echo "$image" | jq -r '.localPath')
            FILENAME=$(basename "$LOCAL_PATH")
            FILEPATH="assets/img/$FILENAME"

            if [ ! -f "$FILEPATH" ]; then
              echo "âš ï¸  File not found: $FILEPATH"
              continue
            fi

            # Get original size
            ORIGINAL_SIZE=$(stat -f%z "$FILEPATH" 2>/dev/null || stat -c%s "$FILEPATH")
            ORIGINAL_SIZE_KB=$((ORIGINAL_SIZE / 1024))

            echo ""
            echo "ðŸ“¸ Processing: $FILENAME (${ORIGINAL_SIZE_KB}KB)"

            # Get file extension
            EXT="${FILENAME##*.}"
            EXT_LOWER=$(echo "$EXT" | tr '[:upper:]' '[:lower:]')

            # Optimize based on file type
            case "$EXT_LOWER" in
              jpg|jpeg)
                echo "  â†’ Optimizing JPEG..."
                # Resize if too large, optimize quality
                convert "$FILEPATH" -resize '1920x1920>' -quality 85 -strip "$FILEPATH"
                jpegoptim --max=85 --strip-all "$FILEPATH"
                ;;
              png)
                echo "  â†’ Optimizing PNG..."
                # Resize if too large
                convert "$FILEPATH" -resize '1920x1920>' -strip "$FILEPATH"
                optipng -o2 "$FILEPATH"
                # If still too large, convert to JPEG
                NEW_SIZE=$(stat -f%z "$FILEPATH" 2>/dev/null || stat -c%s "$FILEPATH")
                if [ $NEW_SIZE -gt 512000 ]; then
                  echo "  â†’ PNG still large, converting to JPEG..."
                  NEW_FILEPATH="${FILEPATH%.png}.jpg"
                  convert "$FILEPATH" -quality 85 "$NEW_FILEPATH"
                  rm "$FILEPATH"
                  FILEPATH="$NEW_FILEPATH"
                fi
                ;;
              webp)
                echo "  â†’ Optimizing WebP..."
                # WebP is already optimized, just resize if needed
                convert "$FILEPATH" -resize '1920x1920>' "$FILEPATH"
                ;;
            esac

            # Get final size
            FINAL_SIZE=$(stat -f%z "$FILEPATH" 2>/dev/null || stat -c%s "$FILEPATH")
            FINAL_SIZE_KB=$((FINAL_SIZE / 1024))
            SAVINGS=$((ORIGINAL_SIZE - FINAL_SIZE))
            SAVINGS_KB=$((SAVINGS / 1024))
            PERCENT=$((SAVINGS * 100 / ORIGINAL_SIZE))

            echo "  âœ… Optimized: ${ORIGINAL_SIZE_KB}KB â†’ ${FINAL_SIZE_KB}KB (saved ${SAVINGS_KB}KB, ${PERCENT}%)"

            # Check if still too large
            if [ $FINAL_SIZE -gt 512000 ]; then
              echo "  âš ï¸  WARNING: Image still exceeds 500KB limit!"
            fi
          done

          echo ""
          echo "âœ¨ Image optimization complete!"
          
      - name: Create branch and commit
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Create and checkout new branch
          BRANCH_NAME="blog-post/issue-${{ github.event.issue.number }}"
          
          # Delete the branch if it exists (from previous failed runs)
          git push origin --delete $BRANCH_NAME 2>/dev/null || true
          
          # Create fresh branch
          git checkout -b $BRANCH_NAME
          
          # Add the new blog post file and any downloaded images
          git add _posts/${{ steps.create-post.outputs.filename }}
          
          # Add images if they exist
          if [ -d "assets/img" ] && [ "$(ls -A assets/img 2>/dev/null)" ]; then
            git add assets/img/*
          fi
          
          # Commit
          git commit -m "Add blog post: ${{ steps.create-post.outputs.title }}
          
          Generated from issue #${{ github.event.issue.number }}"
          
          # Push the branch
          git push origin $BRANCH_NAME
          
      - name: Convert issue to pull request
        uses: actions/github-script@v7
        with:
          script: |
            // Create PR from the branch we just pushed - using issue number to link them
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue: context.issue.number,  // This converts the issue to a PR
              head: `blog-post/issue-${context.issue.number}`,
              base: 'main'
            });
            
            // Add labels to the PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['blog-post']
            });
            
            // Add a comment to note the conversion
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## âœ… Converted to Pull Request\n\nThis issue has been converted to pull request #${pr.number}.\n\nðŸ“„ **Blog post file**: \`_posts/${{ steps.create-post.outputs.filename }}\`\n\nYou can now review and merge the PR when ready to publish.`
            });
            
            // Add 'processed' label to the original issue
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['processed']
            });